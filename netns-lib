#!/bin/bash
#
# Copyright (c) 2012 Tom Grennan
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/ .
#
# This is a test harness for network name spaces.  The only function
# that including scripts should use directly is "netns".  Everything
# else is internal to this shell library. See README for more info.

prog=${0##*/}
: ${topology:=${prog%%-*}}
trap netns-cue EXIT
declare -a commands_
declare -a descriptions_
dry-run () { false; }
no-color () { false; }
html () { false; }
keep-logs () { false; }
quiet () { false; }
verbose () { false; }
shopt -s extglob

while true; do
	case "$1" in
	-h | -help | --help | --usage )
		set netns-help ;;
	-n | --dry-run )
		dry-run () { true; }
		shift ;;
	-o )	shift
		output=$1
		shift ;;
	-o* )	output=${1/-o}
		shift ;;
	--output )
		shift
		output=$1
		shift ;;
	--output=* )
		output=${1/--output=}
		shift ;;
	--no-color | --no-colour )
		no-color () { true; }
		shift ;;
	--html )
		html () { true; }
		shift ;;
	--keep-logs )
		keep-logs () { true; }
		shift ;;
	-q | --quiet )
		quiet () { true; }
		shift ;;
	-v | --verbose )
		verbose () { true; }
		shift ;;
	--* )	set color error Unknown option \'$1\'. ;;
	* )	break ;;
	esac
done

if [ $# -gt 0 ] ; then
	commands_=( "$* ; break" )
	descriptions_=( '' )
	quiet () { true; }
fi

netns () {
	descriptions_+=( "$1" ) ; shift
	if [[ "$1" == +(as-root-here-tee) ]] ; then
		cat > /tmp/$prog-here-${#commands_[@]}
	fi
	commands_+=( "$*" )
}

netns-cue () {
	local -i ecode=0
	local -i successes=0
	local -i failures=0
	local -i i
	for((i=0; i<${#commands_[@]}; i++)) ; do
		local desc=${descriptions_[$i]:-${commands_[$i]%% *}}
		if dry-run ; then
			printf "# %s\n" "$desc"
		fi
		if [ -r /tmp/$prog-here-$i ] ; then
			netns-eval ${commands_[$i]} < /tmp/$prog-here-$i
			ecode=$?
			rm -f /tmp/$prog-here-$i
		else
			netns-eval ${commands_[$i]}
			ecode=$?
		fi
		if dry-run ; then : ; else
			let -i n=i+1
			if [ $ecode -eq 0 ] ; then
				let successes++
				color pass ok $n - $desc
			else
				let failures++
				color error not ok $n - $desc
				echo "${commands_[$i]}" \
					| sed -e 's/^/#	/'
			fi
		fi
	done
	if html ; then
		cat <<-EOF
			<b>FIXME!</b> test summary
			<b>FIXME!</b> html finish stuff
			</body>
			</html>
		EOF
	elif [ $i -gt 0 ] ; then
		printf "Successes %10d\n" $successes
		printf "Failures  %10d\n" $failures
		printf "Total     %10d\n" $i
	fi
	return $ecode
}

netns-help () {
	cat <<-EOF
		Topology: $(netns-var description)    
		$(netns-var diagram)    

		Usage: $prog [OPTIONS] [[FUNCTION|COMMAND] [ARGS]]

		Options:
		    -h, -help, --help, --usage
		        Show this message.
		    -n, --dry-run
		        Show what would be run.
		    --html
		        Use html output rather than plain or colored text.
		    --keep-logs
		    -o, --output <file>
		    --no-color
		    -q, --quiet
		    -v, --verbose
		
		Functions:
		    var [VARIABLE...]
		        Show the named topology variable; examples:
		            topology description
		            topology diagram
		            topology hosts
		            topology nets
		    start | stop
		        Start or stop the configured topology.
		    exec HOST COMMAND
		        Execute a command within the given host name space.
		    <enable|disable>-ip-forward
	EOF
}

netns-var () {
	local var=$topology
	for x; do var+=_$x; done
	eval echo -e \"\$$var\"
}

netns-eval () {
	if [[ "$(type -t netns-$1)" == "function" ]] ; then
		eval "netns-$*"
	else
		eval "$*"
	fi
}

netns-exec () {
	local netns=$topology-$1; shift
	if ! netns-accessible $netns ; then
		color error Can\'t find $netns name space.
		return 1
	fi
	if [ $# -eq 0 ] ; then
		as-root PS1=\'netns:$netns\\$ \' \
			ip netns exec $netns bash --norc -i
	elif [ "$1" = "vtysh" ] ; then
		if [ "$2" = "-c" ] ; then
			shift 2
			as-root VTYSH_PAGER=/usr/bin/less LESS=-FRSX \
				ip netns exec $netns vtysh -c \"$@\"
		else
			as-root VTYSH_PAGER=/usr/bin/less LESS=-FRSX \
				ip netns exec $netns $@
		fi
	else
		as-root ip netns exec $netns $@
	fi
}

netns-start () {
	netns-construct-etc-netns
	netns-construct-hosts
	netns-construct-nets
	netns-construct-routes
	netns-construct-routers
}

netns-stop () {
	netns-raze-routers
	netns-raze-nets
	netns-raze-hosts
	netns-raze-etc-netns
}

netns-construct-etc-netns () {
	as-root mkdir -p /etc/netns
	grep -q netns /proc/mounts ||
		as-root mount -t tmpfs none /etc/netns
}

netns-raze-etc-netns () {
	test `ls /etc/netns | wc -l` -eq 0 &&
		as-root umount /etc/netns
}

netns-construct-hosts () {
	local hostnames=$(netns-var hostnames)
	for host in $(netns-var hosts); do
		local netns=$topology-$host
		as-root ip netns add $netns
		as-root mkdir -p /etc/netns/$netns
		as-root-here-tee /etc/netns/$netns/hostname <<-EOF
			$host
		EOF
		as-root-here-tee /etc/netns/$netns/hosts <<-EOF
			$hostnames
		EOF
		netns-addresses $host lo
	done
}

netns-raze-hosts () {
	for host in $(netns-var hosts); do
		local netns=$topology-$host
		netns-exec $host ip link set lo down
		as-root ip netns delete $netns
		as-root rm -rf /etc/netns/$netns
	done
}

netns-construct-nets () {
	for net in $(netns-var nets); do
		local -i vethidx=0
		local hosts=$(netns-var $net hosts)
		as-root ip link add type veth
		for host in $hosts; do
			as-root ip link set dev veth$vethidx \
				netns $topology-$host name $net
			netns-addresses $host $net
			let vethidx++
		done
	done
}

netns-raze-nets () {
	for net in $(netns-var nets); do
		for host in $(netns-var $net hosts); do
			netns-exec $host ip link set $net down
			netns-exec $host ip link delete $net
			break
		done
	done
}

netns-construct-routes () {
	for host in $(netns-var hosts); do
		local routes=$(netns-var $host routes)
		if [ -n "$routes" ] ; then
			local saveifs=$IFS
			IFS=$(echo -e "\n\b")
			for route in $routes ; do
				netns-exec $host ip route add $route
			done
			IFS=$saveifs
		fi
	done
}

netns-construct-routers () {
	if [ ! -d /etc/quagga/run ] ; then
		as-root mkdir -p /etc/quagga/run
		as-root chown quagga:quagga /etc/quagga/run
	fi
	if [ ! -L /var/run/quagga ] ; then
		as-root ln -sf /etc/quagga/run /var/run/quagga
	fi
	for host in $(netns-var hosts); do
		local netns=$topology-$host
		local etcdir=/etc/netns/$netns/quagga
		local Quagga=$(netns-var $host Quagga)
		if [ -n "$Quagga" ] ; then
			if [ ! -d $etcdir ] ; then
				as-root mkdir $etcdir
				as-root chown quagga:quaggavty $etcdir
				as-root chmod 775 $etcdir
			fi
			if [ ! -d $etcdir/run ] ; then
				as-root mkdir $etcdir/run
				as-root chown quagga:quaggavty $etcdir/run
				as-root chmod 755 $etcdir/run
			fi
			as-root-here-tee $etcdir/vtysh.conf <<-EOF
				service integrated-vtysh-config
				hostname $netns
				username root nopassword
				username $USER nopassword
			EOF
			as-root chown quagga:quaggavty $etcdir/vtysh.conf
			as-root chmod 660 $etcdir/vtysh.conf
			as-root-here-tee $etcdir/Quagga.conf <<-EOF
				hostname $netns
				password zebra
				enable password zebra
				service advanced-vty
				!
				log file /var/log/quagga/$netns
				!
				$Quagga
			EOF
			as-root chown quagga:quagga $etcdir/Quagga.conf
			as-root chmod 640 $etcdir/Quagga.conf
			netns-exec $host /usr/lib/quagga/zebra -d
			for r in rip ripng ospf ospf6 isis bgp ; do
				[[ $Quagga == @(*router $r*) ]] &&
				netns-exec $host /usr/lib/quagga/${r}d -d
			done
			netns-exec $host vtysh -b
		fi
	done
}

netns-raze-routers () {
	shopt -s nullglob
	for host in $(netns-var hosts); do
		local netns=$topology-$host
		for pid_file in /etc/netns/$netns/quagga/run/*.pid ; do
			local pid=$(cat $pid_file)
			as-root kill $pid
		done
		keep-logs || as-root rm -rf /var/log/quagga/$netns
	done
}

netns-addresses () {		# HOST DEV
	local host=$1 dev=$2 ; shift 2
	local addresses=$(netns-var $host $dev)
	if [ -n "$addresses" ] ; then
		local saveifs=$IFS
		IFS=$(echo -e "\n\b")
		for addr in $addresses ; do
			netns-exec $host ip addr add $addr dev $dev
		done
		IFS=$saveifs
		netns-exec $host ip link set $dev up
	fi
}

netns-enable-ip-forward () {
	as-root-here-tee /proc/sys/net/ipv4/ip_forward <<-EOF
		1
	EOF
}

netns-disable-ip-forward () {
	as-root-here-tee /proc/sys/net/ipv4/ip_forward <<-EOF
		0
	EOF
}

netns-wait-for-route () {	# HOST ROUTE [SECONDS (default 3)]
	local host=$1
	local route=$2
	local -i seconds=${3:-5}
	local -i halfseconds
	for (( halfseconds=0; halfseconds < $seconds*2; halfseconds++ )) ; do
		[ -n "$(netns-exec $host ip route list $route)" ] \
			&& return 0
		sleep 0.5
	done
	return 1
}

if dry-run ; then
	netns-accessible () { true; }
	as-root () { echo sudo $@; }
	as-root-here-tee () {
		echo sudo tee $@ '<<-EOF'
		sed 's/^/\t/'
		echo 'EOF'
	}
	nullout () { netns-eval $@; }
else
	netns-accessible () { test -a /var/run/netns/$1; }
	as-root () { eval sudo $@; }
	as-root-here-tee () { sudo tee $@ >/dev/null; }
	nullout () { netns-eval $@ >/dev/null; }
fi

if [ -n "$output" ] ; then
	no-color () { true; }
	exec >$output
fi
if html ; then
	color () {
		if [[ "$1" == +(error|skip|pass|info) ]] ; then
			style=$1
		else
			style=pre
		fi
		shift
		echo -n "<$style>"
		[ $# -gt 0 ] && printf "%s" "$*" || cat
		echo -n "</$style>"
	}
	cat <<-EOF
		<html>
		<header>
		<b>FIXME!<\b> html header stuff with styles...
		</header>
		<body>
	EOF
elif no-color ; then
	color() {
		test -z "$1" && quiet && return
		shift
		[ $# -gt 0 ] && echo "$*" || cat
	}
else
	color () {
		case "$1" in
		error) tput bold; tput setaf 1;; # bold red
		skip)  tput bold; tput setaf 2;; # bold green
		pass)  tput setaf 2;;            # green
		info)  tput setaf 3;;            # brown
		*) quiet && return;;
		esac
		shift
		if [ $# -gt 0 ] ; then
			printf "%s" "$*"
			tput sgr0
			echo
		else
			cat
			tput sgr0
		fi
	}
fi
